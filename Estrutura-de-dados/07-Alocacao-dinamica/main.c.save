#include <stdio.h>
#include <stdlib.h> //Usando Malloc e Calloc
#include <locale.h> //setlocale

/*
void DesalocaVetor(int *v){
    free(v);
    v = NULL;
};
Não funciona pois apenas a copia feita na stack irá receber o valor NULL
O ponteiro passado como parâmetro continuará apontando para a região na heap
*/

void DesalocaVetor(int **v){//É necessário passar o endereço do ponteiro para a heap
    free(*v); //Desaloca o que está armazenado na heap
    *v = NULL; //Sem i
}

int main()
{
    setlocale(LC_ALL, "Portuguese");

    //Alocação estática
    puts("\tAlocação estática");
    int vetor[3] = {10, 9 ,24}; //É um pseudoponteiro

    printf("&vetor = %p, vetor = %p\n", &vetor, vetor);

    int i;
    for(i = 0; i < 3; i++){
        printf("vetor[%d] = %d, (vetor + %d) = %p\n", i, vetor[i], i, (vetor + i));
    }

    //Alocação dinâmica usando Malloc
    puts("\n\tAlocação dinâminca");
    puts("Malloc");
    //Inicializa com "lixo de memória"
    float *v_malloc = (float *)malloc(3 * sizeof(float));

    //Aqui, v_malloc é um ponteiro e armazena o valor do primeiro endereço na heap
    printf("&v_malloc = %p, v_malloc = %p\n", &v_malloc, v_malloc); //Diferente da estática, aqui são diferentes


    int p;
    for(p = 0; p < 3; p++){
        printf("v_malloc[%d] = %f, (v_malloc + %d) = %p\n", p, v_malloc[p], p, (v_malloc + p));
    }

    //Alocação dinãmica usando Calloc
    puts("Calloc");
    //Inicializa com o valor 0 do tipo
    int *v_calloc = (int *)calloc(3, sizeof(int));

    printf("&v_calloc = %p, v_calloc = %p\n", &v_calloc, v_calloc);

    int l;
    for(l = 0; l < 3; l++){
        printf("v_calloc[%d] = %d, &v_calloc[%d] = %p\n", l, v_calloc[l], l, v_calloc + l);
    }

    //Desalocar e mudar o conteúdo de um vetor
    //Antes da função
    printf("\n&v_calloc = %p, v_calloc = %p\n", &v_calloc, v_calloc);

    DesalocaVetor(&v_calloc); //É necessário passar o endereço do ponteiro como parâmetro

    //Depois da função
    printf("\n&v_calloc = %p, v_calloc = %p\n", &v_calloc, v_calloc);
    return 0;
}
